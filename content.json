[{"title":"春天","date":"2017-06-30T09:41:04.000Z","path":"2017/06/30/春天/","text":"春天来了咿咿呀呀的你扭动着肉嘟嘟的小身体缠着我带你去公园踏青青翠的草坪粉嫩的桃花飞舞的小蜜蜂池塘的小蝌蚪每一个春天的气息都引发你一阵的手舞足蹈你快乐的一路欢呼雀跃不忘扭头对我示好你灿烂的笑脸绽放在温暖的春光也推开了我的心门你像细细柔柔的春雨飘洒在我的心上因为有你我的心房一直四季如春感谢有你爱你就像爱生命","tags":[]},{"title":"Ubuntu下Essentia安装及配置","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/Ubuntu下Essentia安装及配置/","text":"之前安装了Yaafe，现在我们来安装Essentia 注意！注意！注意！重要事情说三遍，ubuntu14.04请下载Essentia2.1bate2版本源码解压！！！其他ubuntu版本请注意官网提示信息！ Essentia官网：http://essentia.upf.edu/Essentia官方安装教程：http://essentia.upf.edu/documentation/installing.html [TOC] 一、安装Gaia gaia项目地址：https://github.com/MTG/gaia Essentia依赖于gaia项目，要装Essentia就要先装gaia ###（1）获取Gaia 步骤： 123mkdir Gaia cd Gaia git clone https://github.com/MTG/gaia 完成后在Gaia文件夹下就有了Gaia源码 ###（2）安装Gaia的依赖包 步骤： 1apt-get install build-essential libqt4-dev libyaml-dev swig python-dev pkg-config 到这里gaia就装好了 ###（3）编译安装 进入gaia文件夹下： 123./waf configure --download./waf./waf install 二、安装ffmpgEssentia的安装网站上http://essentia.upf.edu/documentation/installing.html，对依赖包的需求中有这么一段话： libavcodec/libavformat/libavutil/libavresample (from the FFmpeg/LibAv project): for loading/saving any type of audio files (optional) 就是这个依赖可以从ffmgp中得到 因此我们就要装ffmpg，这里有一篇博客对ffmpg写的很清楚，大家自行安装http://www.iyowei.cn/2014/09/linux_ffmpeg/ 三、安装Essentia最后我们来安装Essentia Essentia项目地址：https://github.com/MTG/essentia ###（1）获取Essentia 步骤： 123mkdir Essentia cd Essentiagit clone https://github.com/MTG/essentia.git 完成后在Essentia文件夹下就有了Essentia源码 ###（2）安装Essentia的依赖包 步骤： 1sudo apt-get install build-essential libyaml-dev libfftw3-dev libavcodec-dev libavformat-dev libavresample-dev python-dev libsamplerate0-dev libtag1-dev 1sudo apt-get install python-numpy-dev python-numpy python-yaml 到这里Essentia依赖包就装好了 ###（3）编译安装Essentia 进入Essentia文件夹,输入命令： 1./waf configure --mode=release --build-static --with-python --with-cpptests --with-examples --with-vamp --with-gaia To compile everything you‘ve configured:1./waf To install the C++ library and the python bindings (if configured successfully; you might need to run this command with sudo):1./waf install 好了，到这里Essentia就装好了 为了证明Essentia装好了，到python环境下输入： 1from essentia.standard import * 如果不报错就说明装好了","tags":[]},{"title":"Hadoop1.2.1 伪分布式配置","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/Hadoop1.2.1 伪分布式配置/","text":"虚拟机环境：Ubuntu14.04 一、安装JDK下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html 以下操作如碰到权限问题请sudo 1.在usr文件夹下新建java文件夹，并解压1sudo tar -zxvf jdk.tar.gz(这里是下载的jdk压缩包) -C /usr/java/java-7-sun 2.配置环境变量1sudo vim /etc/profile 将以下内容写入:1234export JAVA_HOME=/usr/java/java-7-sunexport JRE_HOME=/usr/java/java-7-sun/jreexport CLASSPATH=.:\\$JAVA_HOME/lib:\\$JRE_HOME/lib:\\$CLASSPATHexport PATH=\\$JAVA_HOME/bin:\\$JRE_HOME/bin:$PATH 最后java -version看到以下内容即可 二、配置 SSH无密码登录（1）安装ssh1sudo apt-get install openssh-server 使用vim /etc/ssh/sshd_config 将以下内容的注释去掉 （2）生成密钥：1ssh-keygen –t rsa （3）将公钥复制进authorized_keys文件1cat ~/.ssh/id_dsa.pub &gt;&gt; ~/.ssh/authorized_keys （4）测试1ssh localhost 三、安装Hadoop下载地址：http://mirror.bit.edu.cn/apache/hadoop/common/ （1）.将hadoop下载到/opt文件夹，并解压1sudo tar -zxvf hadoop.tar.gz(这里是下载的hadoop压缩包) 进入解压后的hadoop/conf目录即可看到以下文件:这里我们主要配置上图中标红的4个文件: 1.配置hadoop的jdk环境：编辑hadoop-env.sh文件加入jdk环境1sudo vim hadoop-env.sh 2.编辑core-site.xml文件配置工作目录1sudo vim core-site.xml 12345678910111213141516171819202122232425&lt;configuration&gt;&lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/hadoop/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;fs.default.name&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 3.编辑hdfs-site.xml文件配置数据存放目录1sudo vim hdfs-site.xml 123456789&lt;configuration&gt;&lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/hadoop/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 4.编辑mapred-site.xml 任务调度器1sudo vim mapred-site.xml 123456789&lt;configuration&gt;&lt;property&gt;&lt;name&gt;mapred.job.tracker&lt;/name&gt;&lt;value&gt;localhost:9001&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt; （2）配置Hadoop环境变量 sudo vim /etc/profile加入环境变量12export HADOOP_HOME=/opt/hadoop-1.2.1export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH 加完环境变量后执行： source /etc/profile （3）格式化namenode 进入hadoop/bin文件夹 执行1hadoop namenode -format （4）运行hadoop1start-all.sh 输入jps 如果如下图则表示运行成功","tags":[]},{"title":"Ubuntu下Yaafe安装及配置","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/Ubuntu下Yaafe安装及配置/","text":"由于自己在配置yaafe的时候出现了很多问题，所以发篇博客纪念下。 Yaafe官网：http://yaafe.sourceforge.net/Yaafe官方安装教程：http://yaafe.sourceforge.net/manual/install.html [TOC] 一、在Ubuntu下安装一些常用工具###（1）安装常用工具 123456sudo apt-get install gitsudo apt-get install zshsudo apt-get install curlsudo apt-get install python-pipsudo apt-get install cmake-qt-guisudo apt-get install g++ ###（2）配置oh-my-zsh（为了方便） oh-my-zsh项目地址：https://github.com/robbyrussell/oh-my-zsh 装 oh-my-zsh的目的是为了更加方便地使用git，因为它有git的插件，会提示你当前目录是否启用了git版本控制，是否有改动，等等。 在终端下输入命令（两种方法）： 1.使用curl 1sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 2.使用wget1sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 配置完后 输入 sudo chsh，然后重启虚拟机切换到zsh 重启以后终端就是这样啦~ 二、安装Yaafe 官方安装文档：http://yaafe.sourceforge.net/manual/install.html还是推荐大家去看一看的 ###（1）获取Yaafeyaafe源码可以从以下方式获得： 官网下载： http://yaafe.sourceforge.net （不推荐） git： https://github.com/Yaafe/Yaafe/ （推荐） 官网上的版本比较老，对gcc4.6编译会出问题，我就是卡在这卡了好久，最后才发现是这个坑，顿时内牛满面…所以一定要用git上的，而且必需是这个网址的https://github.com/Yaafe/Yaafe/ 步骤： 123mkdir Yaafe cd Yaafegit clone https://github.com/Yaafe/Yaafe.git 完成后在Yaafe文件夹下就有了Yaafe源码 但是….你以为这就完了吗 yaafe使用git的submodule功能来管理它的依赖代码(Eigen), Eigen的代码又在另一个git仓库里。 因此还需如下步骤：在yaafe文件夹下12git submodule initgit submodule update // (可能有点慢) 到这里源码算是下载完了 ###（2）下载Yaafe依赖 Yaafe部署在linux和Max Os X平台上，需要CMake作为编译工具。 Yaafe需要第三方的lib包才能够使用特定的特征。你的电脑需要安装可用的lib包。 argtable是一定需要的。 你可能会用到一些可选的特征，其他的lib包你可能需要用到： libsndfile libmpg HDF5&gt;=1.8 liblapack FFTW3 为了使用yaafe.py你需要Python&gt;=2.5，还有numpy包。 为了获取这些依赖包 我们使用以下命令安装所有依赖包: 1sudo apt-get install cmake cmake-curses-gui libargtable2-0 libargtable2-dev libsndfile1 libsndfile1-dev libmpg123-0 libmpg123-dev libfftw3-3 libfftw3-dev liblapack-dev libhdf5-serial-dev libhdf5-7:i386 libhdf5-7 ###（3）编译安装Yaafe在yaafe文件夹下： 12mkdir buildcd build 接着调用cmake-gui调出cmake的图形界面选择好两个文件夹 接着点击configure ，之后按照下面图片打勾，如果要用到matlab 那么就全部打勾 点击generate后关闭图形化界面，在build文件夹里输入命令： 12makemake install 如果不报错 那么算是装完了 ###（4）配置环境在你安装的路径下（默认路径是/usr/local/lib）你可以找到一下目录（我装完后是没找到这些文件夹，所以只介绍下）： INSTALL_DIR/bin/ INSTALL_DIR/include/ INSTALL_DIR/lib/ INSTALL_DIR/matlab/ INSTALL_DIR/python_packages/ INSTALL_DIR/yaafe_extensions/ . 你必须把yaafe_extensions目录设置到YAAFE_PATH环境里，这样yaafe才能找到可用的特征： 因为用了zsh，所以配置zsh下的环境变量,打开.zshrc文件： 1sudo gedit ~/.zshrc 在末尾加上： export YAAFE_PATH=$INSTALL_DIR/yaafe_extensions $INSTALL_DIR表示安装目录,如果你在/usr/locl/lib下找到这个文件夹则是这样设置： export YAAFE_PATH=/usr/locl/lib/yaafe_extensions 为了更方便的使用Yaafe，你可能要设置环境变量(以下都是指安装在/usr/locl/lib下)： export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/locl/lib ##三、测试测试一下你的yaafe是否安装成功了 新建一个test.py,代码如下: 1234567891011121314151617181920212223242526272829from yaafelib import *import sysdef getFeature(path): fp = FeaturePlan(sample_rate=44100, resample=True, time_start=20,time_limit=40) # 20s fp.addFeature(\"energy: Energy\")#能量 df = fp.getDataFlow() engine = Engine() engine.load(df) afp = AudioFileProcessor() afp.processFile(engine, path) features = engine.readAllOutputs() energy = features.get('energy') energyMean=energy.mean(axis=0) #均值 energyVar =energy.var(axis=0) #方差 print energyMean[0] print energyVar[0] return if __name__ == '__main__': #print sys.path path='/home/jason/gra/music/test/rock/nono.mp3' getFeature(path) 最后的path换成自己歌曲的路径,如果运行正常则表示成功安装.如果出现问题，可以看看自己的动态路径是否已经设置完毕： export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/locl/lib 能输出结果接表示yaafe安装好了。","tags":[]},{"title":"使用Yaafe提取音频特征（MFCC、短时能量、短时过零率等特征）","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/使用Yaafe提取音频特征（MFCC、短时能量、短时过零率等特征）/","text":"前段时间装了Yaafe库，今天就使用Yaafe来提取音频特征。如果没安装Yaafe，请参考我之前的文章。 Yaafe安装教程 [TOC] 一、音频信号预处理###（1）设置音频信号采样率 在对音乐进行特征提取前，必须对音乐文件进行预处理，所有的歌曲必须是同一格式MP3，这样能够减小特征处理时出现的误差。此外，必须设置采样率，采样率是指录音设备在单位时间内对声音信号的采样次数。当今的主流采样率分为三个等级：22.05KHz、44.1KHz、48KHz。而在三个等级中，44.1KHz理论上是CD音质的界限，也就是MP3所具有的采样率。 ###（2）音频信号分帧（设置帧长和帧移） 采样率设置完毕后需要对音乐信号进行分帧处理。音乐信号可以看做是一段连续的曲线，使用无限分割的办法，可将一小段音乐信号看做是短时平稳的，这样每一小段的音乐信号成为分析帧。为了在处理帧于帧之间的信息时，能够让帧于帧之间的信息平滑过渡，我们可以给帧设定一个步长，即帧移，帧移不超过帧的二分之一，它是帧于帧之间未重叠的部分。设置不同的帧和帧移，对于最后研究的结果会造成很大的偏移，因此选择合适的帧和帧移也是一个不可忽略的关键点。 ###（3）音频信号加窗 在处理某些音乐文件时，需要进行快速的傅里叶变化，因为傅立叶变换对应的是无限信号,信号经过分帧后变成有限信号,分帧的信号再进行傅立叶变换后,高频部分将有&quot;泄露&quot;,所以要加窗。常见的加窗处理包括汉宁窗（Hanning）、汉明窗（Hamming）、矩形窗（Square）、三角窗（Triangle）。加窗的目的是为了减少频谱能量泄露，因为在帧需要进行周期延拓处理，得到虚拟无限长的信号，才可以对信号进行快速傅里叶变换等相关处理，可是无限长的信号被截断，其频谱会发生畸形，集中的能量会被分散到两个较宽的频带去。 二、音乐特征介绍 在进行特征提取前简单介绍下音频特征。 ###（1）Mel倒频谱系数 基于Mel倒谱系数（MFCC）是在Mel标度频率域中提取出来的倒频谱系数，是一种感知频域倒谱系数。MFCC以人耳的听觉系统为基础，利用Mel尺度三角滤波器组对傅里叶变换能量系数滤波器得到，并且可以对其频域进行Mel变化，因此Mel频率尺度是最符合人耳听觉系统的一种系数。 ###（2）线性预测编码 线性预测编码（linear predictive coding，LPC）是一种很重要的编码方法，线性预测的基本思路是：由于语言信号样点之间有相关性，所以可以用过去的样本点来预测现在或未来的样本点，即一个语音的抽样能够用过去若干个语音抽样的线性组合来逼近，通过使实际语音信号抽样值和线性预测抽样值之间的误差在均方准则下达到最小值来求解预测系数，而这预测系数就反映了语音信号的特征，故可以用这组语音特征参数进行语音识别或语音合成等。 ###（3）短时能量 短时能量是音频分析中常用的特征之一。音频信号的短时能量随时间变化相对比较明显，可以用来区分清音和浊音。短时能量还可以用来识别静音帧，我们可以给定一个阀值，使得当短时能量的值小于这个阀值时，就认为这个帧是静音帧。我们通常可以把静音帧看作是一段音乐的开始或者是结尾，还可以是音乐的过渡。 好了，其他特征不说了，再说下去我要把度娘搬上来了 ##三、音频特征提取 官方文档：http://yaafe.sourceforge.net/manual/pythonbindings.html 看例子：以下就是一个提取Mfcc平均值、方差的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#!/usr/bin/python# -*- coding:utf-8 -*-from yaafelib import FeaturePlan, Engine, AudioFileProcessordef init(): global engine fp = FeaturePlan(sample_rate=44100, resample=True, time_start=20,time_limit=40) # 采样率44.1Hkz，提取20 - 40s fp.addFeature(&apos;mfcc: MFCC&apos;) # 添加MFCC fp.addFeature(&quot;energy: Energy&quot;) # 能量 fp.addFeature(&quot;zcr: ZCR&quot;) # 过零率 df = fp.getDataFlow() engine = Engine() # 配置Engine engine.load(df) return &apos;Yaafe初始化&apos;def startEngine(path): global afp, features afp = AudioFileProcessor() afp.processFile(engine,path) # 从mp3文件中提取特征，它必需提供engine配置 features = engine.readAllOutputs() # 得到所有特征矩阵 return &apos;Yaafe提取成功&apos;#特征MFCC提取def getMFCC(): mfcc = features.get(&apos;mfcc&apos;) mfccMean=mfcc.mean(axis=0) # 平均值 mfccMean=mfccMean.reshape(-1,) mfccVar=mfcc.var(axis=0) # 方差 mfccVar=mfccVar.reshape(-1,) return mfccMean, mfccVar#测试def main(): init() startEngine(&apos;/home/chenming/Music/test.mp3&apos;) print getMFCC()if __name__ == &apos;__main__&apos;: main() 结果： FeaturePlan： FeaturePlan 是一个按照给定的采样率提取的特征集合addFeature(definition)：Add a feature defined according the feature definition syntax.Parameters: definition (string) – feature definition.Return type: True on success, False on fail. DataFlow： DataFlow对象持有一个描述如何计算一些音频特征的步骤的有向无环图 Engine： Engine对象计算配置给定的特征所需的费用load(dataflow)：Configure engine according to the given dataflow.Parameters: dataflow (DataFlow or string) – dataflow object or filename of a dataflow file.Returns: True on success, False on fail. AudioFileProcessor： AudioFileProcessor对象允许从音频文件中提取特征，并可能将输出特征写入文件，必须给它提供一个EngineprocessFile(engine, filename)：Extract features from the given file using the given engine.If an output format has been set, then output files will be written, else output feature data can be read using engine’s Engine.readOutput() or Engine.readAllOutputs() methods.Parameters:engine (Engine) – engine to use for feature extraction. It must already have been configured.filename (string) – audio file to processReturns:0 on success, negative value on fail 短时能量和过零率就不写上去了，步骤一样features.get(‘zrc’)就好了。","tags":[]},{"title":"责任链模式及其在web容器中的应用","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/责任链模式及其在web容器中的应用/","text":"先来看一个问题一、简单的过滤假如你想设计一个类对一串字符串实现简单的过滤，你会怎么写这个类？对于刚接触编程的人来说可能会像下面这种写法： Message过滤类12345678910111213141516171819public class Message &#123; private String text; public Message() &#123; &#125; public String doFilter()&#123; //去掉空格 return text.replace(&quot; &quot;, &quot;&quot;); &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125;&#125; FilterTest测试类 1234567891011public class FilterTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello World&quot;; Message message = new Message(); message.setText(text); text = message.doFilter();//实现过滤 System.out.println(text); &#125;&#125; 上面的代码实现了简单的字符串过滤类，很明显这样写的代码扩展性很不好，假如我之后想对字符串大小写进行过滤就要重新修改这个类，一点都不灵活。这个时候我们就想把过滤这个行为抽象出来，让每一个具体过滤方法实现这个抽象接口。 二、将过滤抽象出来 Filter接口123public interface Filter &#123; public String doFilter(String text);&#125; SpaceFilter空格过滤类12345678public class SpaceFilter implements Filter&#123; @Override public String doFilter(String text) &#123; // TODO Auto-generated method stub return text.replace(&quot; &quot;, &quot;&quot;); &#125;&#125; UpstrFilter大小写过滤类12345678public class UpstrFilter implements Filter&#123; @Override public String doFilter(String text) &#123; //转换成大写 return text.toUpperCase(); &#125;&#125; Message 类123456789101112131415161718192021222324public class Message &#123; private String text; public Message() &#123; &#125; public String doFilter()&#123; if(text != null &amp;&amp; !&quot;&quot;.equals(text))&#123; //过滤空格 text = new SpaceFilter().doFilter(text); //过滤大写 text = new UpstrFilter().doFilter(text); &#125; //去掉空格 return text; &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125;&#125; FilterTest 测试类12345678910public class FilterTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello World&quot;; Message message = new Message(); message.setText(text); text = message.doFilter();//实现过滤 System.out.println(text); &#125;&#125; 这样假如还有其他过滤手段时只要实现Filter接口，在Message 的doFilter中增加新的过滤手段即可。但是这样还是不够灵活，需要修改Message 类，所以我们可以设计一个类FilterChain来保存所有的Filter，在Message的doFilter方法中遍历执行FilterChain中所有的Filter 三、FilterChain来保存所有的Filter FilterChain类1234567891011121314151617public class FilterChain &#123; List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); public FilterChain addFilter(Filter filter)&#123; filters.add(filter); return this; &#125; public String doFilter(String text)&#123; if(null != text &amp;&amp; !(&quot;&quot;).equals(text))&#123; for(Filter f : filters)&#123; text = f.doFilter(text); &#125; &#125; return text; &#125;&#125; 修改后Message 类12345678910111213141516171819202122232425public class Message &#123; private String text; private FilterChain filterChain; public Message() &#123; &#125; public String doFilter()&#123; return filterChain.doFilter(text); &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public FilterChain getFilterChain() &#123; return filterChain; &#125; public void setFilterChain(FilterChain filterChain) &#123; this.filterChain = filterChain; &#125;&#125; FilterTest测试类1234567891011121314public class FilterTest &#123; public static void main(String[] args) &#123; String text = &quot;Hello World&quot;; Message message = new Message(); message.setText(text); FilterChain filterChain = new FilterChain(); filterChain.addFilter(new SpaceFilter()) .addFilter(new UpstrFilter()); message.setFilterChain(filterChain); text = message.doFilter(); System.out.println(text); &#125;&#125; 到这里已经有点责任链的味道了，最后我们将过滤器和过滤链今行合并 四、合并过滤链 FilterChain类 1234567891011121314151617public class FilterChain implements Filter&#123; List&lt;Filter&gt; filters = new ArrayList&lt;Filter&gt;(); private int index = 0; public FilterChain addFilter(Filter filter)&#123; filters.add(filter); return this; &#125; @Override public String doFilter(String text, FilterChain filterChain) &#123; if(index &gt;= filters.size()) return text; Filter filter = filters.get(index++); return filter.doFilter(text, filterChain); &#125;&#125; SpaceFilter123456789public class SpaceFilter implements Filter&#123; @Override public String doFilter(String text, FilterChain filterChain) &#123; // TODO Auto-generated method stub text = text.replace(&quot; &quot;, &quot;&quot;); return filterChain.doFilter(text, filterChain); &#125;&#125; UpstrFilter123456789public class UpstrFilter implements Filter&#123; @Override public String doFilter(String text, FilterChain filterChain) &#123; //转换成大写 text = text.toUpperCase(); return filterChain.doFilter(text, filterChain); &#125;&#125; Message12345678910111213141516171819202122232425public class Message &#123; private String text; private FilterChain filterChain; public Message() &#123; &#125; public String doFilter()&#123; return filterChain.doFilter(text, filterChain); &#125; public String getText() &#123; return text; &#125; public void setText(String text) &#123; this.text = text; &#125; public FilterChain getFilterChain() &#123; return filterChain; &#125; public void setFilterChain(FilterChain filterChain) &#123; this.filterChain = filterChain; &#125;&#125; web中的过滤器在web中的过滤器就是使用了责任链模式来实现。 我们来看一下tomcat中的过滤器链的源码ApplicationFilterChain，以下是ApplicationFilterChain的doFilter方法1234567891011121314151617181920212223242526272829303132public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; try &#123; java.security.AccessController.doPrivileged( new java.security.PrivilegedExceptionAction&lt;Void&gt;() &#123; @Override public Void run() throws ServletException, IOException &#123; internalDoFilter(req,res); return null; &#125; &#125; ); &#125; catch( PrivilegedActionException pe) &#123; Exception e = pe.getException(); if (e instanceof ServletException) throw (ServletException) e; else if (e instanceof IOException) throw (IOException) e; else if (e instanceof RuntimeException) throw (RuntimeException) e; else throw new ServletException(e.getMessage(), e); &#125; &#125; else &#123; internalDoFilter(request,response); &#125; &#125; 其中internalDoFilter方法就是过滤器链调用过滤器的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576private void internalDoFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException &#123; // Call the next filter if there is one if (pos &lt; n) &#123; ApplicationFilterConfig filterConfig = filters[pos++]; try &#123; Filter filter = filterConfig.getFilter(); if (request.isAsyncSupported() &amp;&amp; &quot;false&quot;.equalsIgnoreCase( filterConfig.getFilterDef().getAsyncSupported())) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; if( Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res, this&#125;; SecurityUtil.doAsPrivilege (&quot;doFilter&quot;, filter, classType, args, principal); &#125; else &#123; filter.doFilter(request, response, this); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(&quot;filterChain.filter&quot;), e); &#125; return; &#125; // We fell off the end of the chain -- call the servlet instance try &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(request); lastServicedResponse.set(response); &#125; if (request.isAsyncSupported() &amp;&amp; !servletSupportsAsync) &#123; request.setAttribute(Globals.ASYNC_SUPPORTED_ATTR, Boolean.FALSE); &#125; // Use potentially wrapped request from this point if ((request instanceof HttpServletRequest) &amp;&amp; (response instanceof HttpServletResponse) &amp;&amp; Globals.IS_SECURITY_ENABLED ) &#123; final ServletRequest req = request; final ServletResponse res = response; Principal principal = ((HttpServletRequest) req).getUserPrincipal(); Object[] args = new Object[]&#123;req, res&#125;; SecurityUtil.doAsPrivilege(&quot;service&quot;, servlet, classTypeUsedInService, args, principal); &#125; else &#123; servlet.service(request, response); &#125; &#125; catch (IOException | ServletException | RuntimeException e) &#123; throw e; &#125; catch (Throwable e) &#123; e = ExceptionUtils.unwrapInvocationTargetException(e); ExceptionUtils.handleThrowable(e); throw new ServletException(sm.getString(&quot;filterChain.servlet&quot;), e); &#125; finally &#123; if (ApplicationDispatcher.WRAP_SAME_OBJECT) &#123; lastServicedRequest.set(null); lastServicedResponse.set(null); &#125; &#125; &#125; 可以看到，tomcat正是通过filter.doFilter(request, response, this);方法使得每一个过滤器都持有过滤器链，在处理完一个过滤器后，调用下一个过滤器，直到所有过滤器执行完毕。","tags":[]},{"title":"使用scikit-learn进行音乐分类","date":"2017-06-30T06:41:04.000Z","path":"2017/06/30/使用scikit-learn进行音乐分类/","text":"之前简要说了下Yaafe和Essentia的安装使用，自己也专门对这两个框架做了封装，实现了各个特征提取的接口，并将特征值存到本地文件中方便训练时使用。下面这张图是对应提取的特征数据，一共35种特征，每种特征维度不一样。例如MFCC最大值维度为13维。 这里的音乐分类主要是按情感进行分类，一共分成7种情感：happy，sad，passion，excited，quiet，nostalgic，relax。 一、得到训练数据123456789101112131415161718192021222324252627282930313233def getTrainData(train_path, train_mode, mode_name, featureList): num = [] train_data = [] train_target = [] introFeature = [] for i in range(len(train_mode)): allFeature = [] # print len(train_mode),len(train_path),i,train_path[0],train_path[1] # print tool.getFileNum(train_path[i]) num.append(tool.getFileNum(train_path[i])) for j in tool.getAllFile(train_path[i]): yl.startEngine(j) el.startLoader(j) oneFeature, introFeature = getFeature(yl, el, featureList) allFeature.append(oneFeature) # print allFeature # 判断是否有歌曲的特征被提取出 if len(allFeature) == 0: print &apos;无音频文件&apos; else: wf.setMode(train_mode[i]) # 设置类别和目录．输出 wf.setFeaturePrintPath(train_path[i]) # 音乐目录/feature_num/train_mode[i].txt readme.txt wf.writeFeature(allFeature, introFeature) tool.mkdir(&apos;dataSystem/&apos; + mode_name) wf.writeDetial(&apos;dataSystem/&apos; + mode_name + &apos;/feature.txt&apos;, featureList) for singleFeature in allFeature: train_data.append(singleFeature) # 设置训练数据 train_target.append(i) # 设置训练目标 return train_data, train_target train_path和train_mode分别表示传入的一类音乐文件夹路径，该类别标签，例如train_path=‘/home/chenming/Music/Happy’表示happy类型音乐文件夹，train_mode=‘happy’表示该组训练数据类型为happy。featureList是传入的需要提取的特征，例如featureList=[1,2,3]表示提取FEATURES中对应1,2,3位置的特征（上面第一张图片）。 train_data = []和 train_target = []分别是得到的训练数据以及该数据对应的标签。最终特征数据存到/home/chenming/Music/Happy下feature_num/happy.txt中 二、训练 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def train(train_data, train_target, train_mode, mode_name): # 数据标准化 train_data = np.array(train_data) train_target = np.array(train_target) # sklearn提供的数据处理方法 # train_data = preprocessing.scale(train_data) # test_data = preprocessing.scale(test_data) (meanData, stdData) = tool.trainDataStandardNor(train_data) # 存储 np.savetxt(&apos;dataSystem/&apos; + mode_name + &apos;/meanData.txt&apos;, meanData) np.savetxt(&apos;dataSystem/&apos; + mode_name + &apos;/stdData.txt&apos;, stdData) wf.writeDetial(&apos;dataSystem/&apos; + mode_name + &apos;/modeList.txt&apos;, train_mode) #np.savetxt(&apos;dataSystem/&apos; + mode_name + &apos;/modeList.txt&apos;, train_mode) &apos;&apos;&apos; c=np.arange(1,10,1) g=np.arange(0,1,0.1) tuned_parameters = [&#123;&apos;kernel&apos;: [&apos;rbf&apos;], &apos;gamma&apos;: g,&apos;C&apos;: c&#125;] #print classifierType,type(classifierType) &apos;&apos;&apos; clf = svm.SVC() if classifierType == &apos;svm&apos;: clf = svm.SVC() elif classifierType == &apos;knn&apos;: clf = neighbors.KNeighborsClassifier() # knn K-临近算法 elif classifierType == &apos;tree&apos;: clf = tree.DecisionTreeClassifier() # 决策树 # clf = grid_search.GridSearchCV(svm.SVC(), tuned_parameters, cv=3) #svm支持向量机 print train_data print train_target clf.fit(train_data, train_target) # clf.fit(train_data) # clf.score(test_data, test_target) # showStyleDetail(test_data,test_target,clf) from sklearn.externals import joblib tool.mkdir(&apos;svcSystem/&apos; + mode_name) joblib.dump(clf, &apos;svcSystem/&apos; + mode_name + &apos;/svc1.pkl&apos;) # clf2=joblib.load(&apos;svc/svc1.pkl&apos;) # print clf.score(test_data, test_target) # showDetail(test_data,test_target,clf2) # print clf.best_estimator_ return &apos;训练成功,模型&apos; + mode_name + &apos;存储成功,&apos;+&apos;位置:svcSystem/&apos;+mode_name +&apos;/svc1.pkl&apos; (meanData, stdData) = tool.trainDataStandardNor(train_data)是对数据进行归一化处理，代码如下：1234567891011121314def trainDataStandardNor(featureMatrix): #print &apos;train_feature&apos;,featureMatrix meanData=featureMatrix.mean(axis=0) #平均值 stdData=featureMatrix.std(axis=0) #标准差 for data in featureMatrix: for i in range(len(data)): if stdData[i]==0: data[i]=0 else: print data[i] data[i]=(data[i]-meanData[i])/stdData[i] return (meanData,stdData) http://www.tuicool.com/articles/qeIzI3F 这篇博客介绍了Scikit-Learn的使用。 三、测试1234567891011121314151617181920212223242526272829def test(test_data, test_target, test_mode, mode_name): test_data = np.array(test_data) test_target = np.array(test_target) print &apos;test_data:&apos;, test_data print &apos;test_target:&apos;, test_target print &apos;test_mode:&apos;, test_mode path1 = &apos;dataSystem/&apos; + mode_name + &apos;/meanData.txt&apos; path2 = &apos;dataSystem/&apos; + mode_name + &apos;/stdData.txt&apos; path3 = &apos;svcSystem/&apos; + mode_name + &apos;/svc1.pkl&apos; path4 = &apos;dataSystem/&apos; + mode_name + &apos;/modeList.txt&apos; print &apos;数据路径:&apos; + &apos;dataSystem/&apos; + mode_name + &apos;和svcSystem/&apos; + mode_name meanData = np.loadtxt(path1) stdData = np.loadtxt(path2) modeList = wf.readFileTxt(path4) mode = wf.readFileTxt(&apos;dataSystem/&apos; + mode_name + &apos;/modeList.txt&apos;) tool.testDataStandardNor(test_data, meanData, stdData) from sklearn.externals import joblib clf = joblib.load(path3) s = showDetail(clf, test_data, test_target, modeList) return s showDetail函数展示结果：12345678910111213141516171819202122232425262728293031323334353637383940414243444546def showDetail(clf, test_data, test_target, mode): modeNum = [] expected = test_target predicted = clf.predict(test_data) # print expected # print predicted # print test_mode out = &apos;&apos;&apos;*******准确率=被识别为该分类的正确分类记录数/被识别为该分类的记录数*******召回率=被识别为该分类的正确分类记录数/测试集中该分类的记录总数*******F1-score=2（准确率 * 召回率）/（准确率 + 召回率），F1-score是F-measure（又称F-score）beta=1时的特例*******support=测试集中该分类的记录总数\\n &apos;&apos;&apos; for d in mode: print &apos;d&apos;, d out = out + str(metrics.classification_report(expected, predicted, target_names=mode)) print (metrics.classification_report(expected, predicted, target_names=mode)) result = metrics.confusion_matrix(expected, predicted) out = out + &apos;\\n预测数目:\\t&apos; print &apos;预测数目:\\t&apos;, for j in range(len(mode)): out = out + str(mode[j]) + &apos;\\t&apos; print mode[j], &apos;\\t&apos;, out = out + &apos;\\n\\n&apos; print &apos;\\n&apos; for i in range(len(result)): out = out + &apos;测试数据&apos; + str(i + 1) + &apos;:\\t&apos; print &apos;测试数据&apos; + str(i + 1) + &apos;:\\t&apos;, num = 0 for p in range(len(result[i])): out = out + str(result[i][p]) + &apos;\\t&apos; print result[i][p], &apos;\\t&apos;, num = num + result[i][p] out = out + &apos;\\n&apos; print &apos;\\n&apos; modeNum.append([result[i][i], num]) out = out + &apos;\\n&apos; for k in range(len(modeNum)): out = out + str(mode[k]) + &apos;:\\t命中/总数:&apos; + str(modeNum[k][0]) + &apos;/&apos; + str(modeNum[k][1]) + &apos;\\t正确率:&apos; + str( tool.ratio(modeNum[k][0], modeNum[k][1])) + &apos;\\n&apos; print mode[k], &apos;:\\t命中/总数:&apos;, modeNum[k][0], &apos;/&apos;, modeNum[k][1], &apos;\\t正确率:&apos;, tool.ratio(modeNum[k][0], modeNum[k][1]) return out 以下是测试结果测试50首happy歌曲音乐，得到47首正确，3首识别错误:","tags":[]}]